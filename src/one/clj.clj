(ns one.clj)

(def clj {"program _ph=0 _ph=1" "(use 'clojure.string)\n_ph=1"
           "main _ph=0name _ph=1" "(defn -main [& _ph=0name]\n_ph=1)"
           ;; Printing and intput
           "println _ph=0" "(println _ph=0)\n"
           "print _ph=0" "(print _ph=0)\n"
           "read-input" "(read-line)"
           ;; Types
           "void" ""
           "empty" "nil"
           "str" "java.lang.String"
           "int" "java.lang.Integer"
           "double" "java.lang.Double"
           "bool" "java.lang.Boolean"
           "closure" ""
           "object" "java.lang.Object"
           "to-str _ph=0" "(str _ph=0)"
           "to-int _ph=0" "(Integer/parseInt _ph=0)"
           "to-double _ph=0" "(Double/parseDouble _ph=0)"
           "to-bool _ph=0" "(Boolean/parseBoolean _ph=0)"
           ;; Variables and constants
           "_ph=0 var _ph=1name _ph=2" "(def _ph=1name (atom _ph=2))\n"
           "_ph=0 let _ph=1name _ph=2" "(def _ph=1name _ph=2)\n"
           "_ph=0 global-var _ph=1name _ph=2" "(def _ph=1name (atom _ph=2))\n"
           "_ph=0 global-let _ph=1name _ph=2" "(def _ph=1name _ph=2)\n"
           "alter _ph=0name _ph=1" "(reset! _ph=0name _ph=1)\n"
           "$ _ph=0name" "@_ph=0name"
           "@ _ph=0name" "_ph=0name"
           ;; Math
           "+ _ph=0 _ph=1" "(+ _ph=0 _ph=1)"
           "- _ph=0 _ph=1" "(- _ph=0 _ph=1)"
           "* _ph=0 _ph=1" "(* _ph=0 _ph=1)"
           "/ _ph=0 _ph=1" "(/ _ph=0 _ph=1)"
           "sqrt _ph=0" "Math/sqrt _ph=0"
           "sin _ph=0" "Math/sin _ph=0"
           "cos _ph=0" "Math/cos _ph=0"
           "tan _ph=0" "Math/tan _ph=0"
           "abs _ph=0" "Math/abs _ph=0"
           "rand-int _ph=0" "(rand-int _ph=0)"
           ;; String
           "strlen _ph=0" "(count _ph=0)"
           "substr _ph=0 _ph=1 _ph=2" "(subs _ph=0 _ph=1 _ph=2)"
           "split _ph=0 _ph=1" "(split _ph=0 _ph=1)"
           "split-lines _ph=0" "(split-lines _ph=0)"
           "trim _ph=0" "(trim _ph=0)"
           "concat _ph=0 _ph=1" "(str _ph=0 _ph=1)"
           ;; Boolean
           "== _ph=0 _ph=1" "(== _ph=0 _ph=1)"
           "= _ph=0 _ph=1" "(= _ph=0 _ph=1)"
           "> _ph=0 _ph=1" "(> _ph=0 _ph=1)"
           "< _ph=0 _ph=1" "(< _ph=0 _ph=1)"
           ">= _ph=0 _ph=1" "(>= _ph=0 _ph=1)"
           "<= _ph=0 _ph=1" "(<= _ph=0 _ph=1)"
           ;; Control
           "if _ph=0 _ph=1" "(if _ph=0 (do\n_ph=1)\n)\n"
           "if _ph=0 _ph=1 else _ph=2" "(if _ph=0 (do\n_ph=1) (do\n_ph=2))\n"
           "while _ph=0 _ph=1" "(while _ph=0 _ph=1)\n"
           "loop-times _ph=0name _ph=1 _ph=2" "(dotimes [_ph=0name _ph=1]\n_ph=2)\n"
           ;; Functions
           "func _ph=0name _ph=1 _ph=2name -> _ph=3 _ph=4" "(defn _ph=0name [_ph=2name]\n_ph=4name)\n"
           "call _ph=0name _ph=1" "(_ph=0name _ph=1)\n"
           "call-> _ph=0name _ph=1" "(_ph=0name _ph=1)"
           "closure _ph=0" "(fn []\n_ph=0)"
           "call-cls _ph=0" "(_ph=0)\n"
           ;; Array
           "int-array" ""
           "str-array" "clojure.lang.PersistentVector"
           "bool-array" "clojure.lang.PersistentVector"
           "double-array" "clojure.lang.PersistentVector"
           "closure-array" "clojure.lang.PersistentVector"
           "object-array" "clojure.lang.PersistentVector"
           "new-int-array" "[]"
           "new-str-array" "[]"
           "new-bool-array" "[]"
           "new-double-array" "[]"
           "new-closure-array" "[]"
           "new-object-array" "[]"
           "add-element _ph=0 _ph=1" "(conj _ph=0 _ph=1)"
           "set-element _ph=0 _ph=1 _ph=2" "(reset! _ph=0 (assoc _ph=0 _ph=1 _ph=2))\n"
           "get _ph=0 _ph=1" "(get _ph=0 _ph=1)"
           "count _ph=0" "(count _ph=0)"
           ;; Time
           "wait _ph=0" "(try (Thread/sleep _ph=0) (catch Exception e))"
           "get-time _ph=0name" "long _ph=0name = new Date().getTime();\n"
           ;; Persistence
           "write-key _ph=0 _ph=1" "(spit _ph=0 _ph=1)"
           "read-key _ph=0 _ph=1 into _ph=2name" "(reset! _ph=2name _ph=1)\n(try (reset! _ph=2name (slurp _ph=0)) (catch Exception e))"})